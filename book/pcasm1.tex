% -*-latex-*-
\chapter{Introduction}
\section{Number Systems}

Memory in a computer consists of numbers. Computer memory does not
store these numbers in decimal (base 10). Because it greatly
simplifies the hardware, computers store all information in a binary
(base 2) format. First let's review the decimal system.

\subsection{Decimal\index{decimal}}

Base 10 numbers are composed of 10 possible digits (0-9). Each digit
of a number has a power of 10 associated with it based on its position
in the number. For example:
\begin{displaymath}
234 = 2 \times 10^2 + 3 \times 10^1 + 4 \times 10^0
\end{displaymath}

\subsection{Binary\index{binary|(}}

Base 2 numbers are composed of 2 possible digits (0 and 1). Each digit
of a number has a power of 2 associated with it based on its position
in the number. (A single binary digit is called a bit.) For
example\footnote{The 2 subscript is used to show that the number is
represented in binary, not decimal}:
\begin{eqnarray*}
11001_2 & = & 1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1
              + 1 \times 2^0 \\
 & = & 16 + 8 + 1 \\
 & = & 25
\end{eqnarray*}

This shows how binary may be converted to decimal. Table~\ref{tab:dec-bin}
shows how the first few numbers are represented in binary.
\begin{table}[t]
\begin{center}
\begin{tabular}{||c|c||cc||c|c||}
\hline
Decimal & Binary & & & Decimal & Binary \\
\hline
0       & 0000   & & & 8       & 1000 \\
\hline
1       & 0001   & & & 9       & 1001 \\
\hline
2       & 0010   & & & 10      & 1010 \\
\hline
3       & 0011   & & & 11      & 1011 \\
\hline
4       & 0100   & & & 12      & 1100 \\
\hline
5       & 0101   & & & 13      & 1101 \\
\hline
6       & 0110   & & & 14      & 1110 \\
\hline
7       & 0111   & & & 15      & 1111 \\
\hline
\end{tabular}
\caption{Decimal 0 to 15 in Binary\label{tab:dec-bin}}
\end{center}
\end{table}


\begin{figure}[h]
\begin{center}
%I think this example was confusing
%\begin{tabular}{|rrrrrrrrp{.1cm}|p{.1cm}rrrrrrrr|}
%\hline
%& \multicolumn{7}{c}{No previous carry} & & & \multicolumn{7}{c}{Previous carry} & \\
%\hline
%&  0 & &  0 & &  1 & &  1 & & &  0 & &  0 & &  1 & & 1  & \\
%& +0 & & +1 & & +0 & & +1 & & & +0 & & +1 & & +0 & & +1 &  \\
%\cline{2-2} \cline{4-4} \cline{6-6} \cline{8-8} \cline{11-11} \cline{13-13} \cline{15-15} \cline{17-17}
%& 0  & & 1  & & 1  & & 0  & & & 1  & & 0  & & 0  & & 1 & \\
%&    & &    & &    & & c  & & &    & & c  & & c  & & c & \\
%\hline
%\end{tabular}
\begin{tabular}{r}
 $11\overset{1}{0}\overset{1}{1}1_2$ \\
+$10001_2$ \\
\hline
$101100_2$ \\
\end{tabular}

\caption{Binary addition\label{fig:bin-add}}
\index{binary!addition}
\end{center}
\end{figure}

Figure~\ref{fig:bin-add} shows how individual binary digits ({\em
i.e.}, bits) are added. Here's an example:



If one considers the following decimal division:
\[ 1234 \div 10 = 123\; r\; 4 \]
he can see that this division strips off the rightmost decimal digit of
the number and shifts the other decimal digits one position to the right.
Dividing by two performs a similar operation, but for the binary digits
of the number. Consider the following binary division:
\[ 1101_2 \div 10_2 = 110_2\; r\; 1 \]
This fact can be used to convert a decimal
number to its equivalent binary representation as
Figure~\ref{fig:dec-convert} shows. This method finds the rightmost
digit first, this digit is called the \emph{least significant bit} (lsb).
The leftmost digit is called the \emph{most significant bit} (msb).
The basic unit of memory consists of 8 bits and is called a \emph{byte}.
\index{binary|)}

\begin{figure}[t]
%\centering
\fbox{\parbox{\textwidth}{
\begin{center}
\begin{tabular}{cc}
Decimal & Binary \\
$25 \div 2 = 12\;r\;1$ & $11001 \div 10 = 1100\;r\;1$ \\
$12 \div 2 = 6\;r\;0$  & $1100 \div 10 = 110\;r\;0$ \\
$6 \div 2 = 3\;r\;0$   & $110 \div 10 = 11\;r\;0$ \\
$3 \div 2 = 1\;r\;1$   & $11 \div 10 = 1\;r\;1$ \\
$1 \div 2 = 0\;r\;1$   & $1 \div 10 = 0\;r\;1$ \\
\end{tabular}
\end{center}
\centering
Thus $25_{10} = 11001_{2}$
}}
\caption{Decimal conversion to Binary \label{fig:dec-convert}}
\end{figure}

\subsection{Hexadecimal\index{hexadecimal|(}}

Hexadecimal numbers use base 16. Hexadecimal (or \emph{hex} for short) can be
used as a shorthand for binary numbers. Hex has 16 possible
digits. This creates a problem since there are no symbols to use for
these extra digits after 9. By convention, letters are used for these
extra digits. The 16 hex digits are 0-9 then A, B, C, D, E and F. The
digit A is equivalent to 10 in decimal, B is 11, etc. Each digit of a
hex number has a power of 16 associated with it. Example:
\begin{eqnarray*}
\rm
2BD_{16} & = & 2 \times 16^2 + 11 \times 16^1 + 13 \times 16^0 \\
         & = & 512 + 176 + 13 \\
         & = & 701 \\
\end{eqnarray*}
To convert from decimal to hex, use the same idea that was used for
binary conversion except divide by 16. See Figure~\ref{fig:hex-conv} for
an example.

\begin{figure}[t]
\fbox{\parbox{\textwidth}{
\begin{center}
\begin{tabular}{ccc}
$589 \div 16$ & = & $36\;r\;13$ \\
$36 \div 16$ & = & $2\;r\;4$ \\
$2 \div 16$ & = & $0\;r\;2$ \\
\end{tabular}
\end{center}
\centering
Thus $589 = 24\mathrm{D}_{16}$
}}
\caption{Decimal conversion to Hexadecimal \label{fig:hex-conv}}
\end{figure}

The reason that hex is useful is that there is a very simple way to
convert between hex and binary. Binary numbers get large and
cumbersome quickly. Hex provides a much more compact way to represent
binary.

To convert a hex number to binary, simply convert each hex digit to a
4-bit binary number. For example, $\mathrm{24D}_{16}$ is converted to
\mbox{$0010\;0100\; 1101_2$}. Note that the leading zeros of the
4-bits are important! If the leading zero for the middle digit of
$\mathrm{24D}_{16}$ is not used the result is wrong. Converting from
binary to hex is just as easy. One does the process in reverse. Convert
each 4-bit segments of the binary to hex. Start from the
right end, not the left end of the binary number. This ensures that
the process uses the correct 4-bit segments\footnote{If it is not
clear why the starting point makes a difference, try converting the
example starting at the left.}. Example:\newline

\begin{tabular}{cccccc}
$110$ & $0000$ & $0101$ & $1010$ & $0111$ & $1110_2$ \\
  $6$ & $0$    &   $5$  &   A  &  $7$   &    $\mathrm{E}_{16}$ \\
\end{tabular}\newline

A 4-bit number is called a \emph{nibble} \index{nibble}. Thus each hex
digit corresponds to a nibble. Two nibbles make a byte and so a byte
can be represented by a 2-digit hex number. A byte's value ranges from
0 to 11111111 in binary, 0 to FF in hex and 0 to 255 in decimal.
\index{hexadecimal|)}

\subsection{Octal\index{octal|(}}

Octal numbers use base 8. Less common than hexidecimal, octal can also be
used as a shorthand for binary numbers.  It is often used when the numbers
can be broken into groups of three bits.  The first fifteen numbers in octal are shown with their binary equivalents in Table~\ref{tab:oct-bin}.
\begin{table}[t]
\begin{center}
\begin{tabular}{||c|c||cc||c|c||}
\hline
Octal & Binary & & & Octal & Binary \\
\hline
0       & 000   & & & 10       & 001 000 \\
\hline
1       & 001   & & & 11       & 001 001 \\
\hline
2       & 010   & & & 12      & 001 010 \\
\hline
3       & 011   & & & 13      & 001 011 \\
\hline
4       & 100   & & & 14      & 001 100 \\
\hline
5       & 101   & & & 15      & 001 101 \\
\hline
6       & 110   & & & 16      & 001 110 \\
\hline
7       & 111   & & & 17      & 001 111 \\
\hline
\end{tabular}
\caption{Octal 0 to 17 in Binary\label{tab:oct-bin}}
\end{center}
\end{table}

\index{octal|)}

\section{Computer Organization}

\subsection{Memory\index{memory|(}}

The basic unit of memory is a byte. \index{byte} \MarginNote{Memory is
measured in units of kilobytes (~$2^{10} = 1,024$ bytes), megabytes
(~$2^{20} = 1,048,576$ bytes) and gigabytes (~$2^{30} = 1,073,741,824$
bytes).}A computer with 32 megabytes of memory can hold roughly 32
million bytes of information. Each byte in memory is labeled by a
unique number known as its address as Figure~\ref{fig:memory} shows.

\begin{figure}[ht]
\begin{center}
\begin{tabular}{rcccccccc}
Address & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\cline{2-9}
Memory & \multicolumn{1}{|c}{2A}  & \multicolumn{1}{|c}{45}
       & \multicolumn{1}{|c}{B8} & \multicolumn{1}{|c}{20}
       & \multicolumn{1}{|c}{8F} & \multicolumn{1}{|c}{CD}
       & \multicolumn{1}{|c}{12} & \multicolumn{1}{|c|}{2E} \\
\cline{2-9}
\end{tabular}
\caption{ Memory Addresses \label{fig:memory} }
\end{center}
\end{figure}

\begin{table}[t]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Term & Size \\ \hline
nibble & 1/2 bytes \\ \hline
byte & 1 byte \\ \hline
word & 2 bytes \\ \hline
double word & 4 bytes \\ \hline
quad word & 8 bytes \\ \hline
paragraph & 16 bytes \\ \hline
\end{tabular}
\caption{ Units of Memory \label{tab:mem_units} }
\end{center}
\end{table}

Often memory is used in larger chunks than single bytes. On
the PC architecture, names have been given to these larger sections of
memory as Table~\ref{tab:mem_units} shows.

All data in memory is numeric. Characters are stored by using a
\emph{character code} that maps numbers to characters. One of the
most common character codes is known as \emph{ASCII} (American
Standard Code for Information Interchange). A new, more complete code
that is supplanting ASCII is Unicode. One key difference between the
two codes is that ASCII uses one byte to encode a character, but
Unicode uses multiple bytes. There are several different forms of Unicode.
On x86 C/C++ compilers, Unicode is represented in code using the
{\code wchar\_t} type and the UTF-16 encoding which uses 16 bits (or a
\emph{word}) per character. For example, ASCII maps the byte $41_{16}$
($65_{10}$) to the character capital \emph{A}; UTF-16 maps it to the
word $0041_{16}$. Since ASCII uses a byte, it is limited to only 256
different characters\footnote{In fact, ASCII only uses the lower 7-bits
and so only has 128 different values to use.}. Unicode extends the ASCII
values and allows many more characters to be represented. This is important
for representing characters for all the languages of the world.
\index{memory|)}

\subsection{The CPU\index{CPU|(}}

The Central Processing Unit (CPU) is the physical device that performs
instructions. The instructions that CPUs perform are generally very
simple. Instructions may require the data they act on to be in special
storage locations in the CPU itself called
\emph{registers}. \index{register} The CPU can access data in registers
much faster than data in memory. However, the number of registers in a
CPU is limited, so the programmer must take care to keep only
currently used data in registers.

The instructions a type of CPU executes make up the CPU's
\emph{machine language}. \index{machine language} Machine programs
have a much more basic structure than higher-level languages. Machine
language instructions are encoded as raw numbers, not in friendly text
formats. A CPU must be able to decode an instruction's purpose very
quickly to run efficiently. Machine language is designed with this
goal in mind, not to be easily deciphered by humans. Programs written
in other languages must be converted to the native machine language of
the CPU to run on the computer. A \emph{compiler} \index{compiler} is
a program that translates programs written in a programming language
into the machine language of a particular computer architecture. In
general, every type of CPU has its own unique machine language. This
is one reason why programs written for a Mac can not run on an
IBM-type PC.

Computers use a \emph{clock} \index{clock} to synchronize the
execution of the \MarginNote{\emph{GHz} stands for gigahertz or one
billion cycles per second.  A 1.5 GHz CPU has 1.5 billion clock pulses
per second.} instructions.  The clock pulses at a fixed frequency
(known as the \emph{clock speed}). When you buy a 1.5 GHz computer,
1.5 GHz is the frequency of this clock\footnote{Actually, clock pulses
are used in many different components of a computer. The other
components often use different clock speeds than the CPU.}. The clock
does not keep track of minutes and seconds. It simply beats at a
constant rate. The electronics of the CPU uses the beats to perform
their operations correctly, like how the beats of a metronome help one
play music at the correct rhythm.  The number of beats (or as they are
usually called \emph{cycles}) an instruction requires depends on the
CPU generation and model. The number of cycles depends on the
instructions before it and other factors as well.


\subsection{The 80x86 family of CPUs\index{CPU!80x86}}

IBM-type PC's contain a CPU from Intel's 80x86 family (or a clone of one).
The CPU's in this family all have some common features including a base
machine language. However, the more recent members greatly enhance the
features.
\begin{description}

\item[8088,8086:] These CPU's from the programming standpoint are
identical. They were the CPU's used in the earliest PC's. They provide
several 16-bit registers: AX, BX, CX, DX, SI, DI, BP, SP, CS, DS, SS,
ES, IP, FLAGS. They only support up to one megabyte of memory and only
operate in \emph{real mode}.  In this mode, a program may access any
memory address, even the memory of other programs! This makes
debugging and security very difficult! Also, program memory has to be
divided into \emph{segments}. Each segment can not be larger than
64K.

\item[80286:] This CPU was used in AT class PC's. It adds some new
instructions to the base machine language of the 8088/86.  However,
its main new feature is \emph{16-bit protected mode}.  In this mode,
it can access up to 16 megabytes and protect programs from accessing
each other's memory. However, programs are still divided into
segments that could not be bigger than 64K.

\item[80386:] This CPU greatly enhanced the 80286. First, it extends many
of the registers to hold 32-bits (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP,
EIP) and adds two new 16-bit registers FS and GS. It also adds a new
\emph{32-bit protected mode}. In this mode, it can access up to 4 gigabytes.
Programs are again divided into segments, but now each segment can also be
up to 4 gigabytes in size!

\item[80486/Pentium/Pentium Pro:] These members of the 80x86 family add
very few new features. They mainly speed up the execution of the
instructions.

\item[Pentium MMX:] This processor adds the MMX (MultiMedia eXtensions)
instructions to the Pentium. These instructions can speed up common graphics
operations.

\item[Pentium II:] This is the Pentium Pro processor with the MMX instructions
added. (The Pentium III is essentially just a faster Pentium II.)

\end{description}
\index{CPU|)}

\subsection{8086 16-bit Registers\index{register|(}}

The original 8086 CPU provided four 16-bit general purpose registers:
AX, BX, CX and DX. Each of these registers could be decomposed into
two 8-bit registers. For example, the AX register could be decomposed
into the AH and AL registers as Figure~\ref{fig:AX_reg} shows. The AH
register contains the upper (or high) 8 bits of AX and AL contains the
lower 8 bits of AX. Often AH and AL are used as independent one byte
registers; however, it is important to realize that they are not
independent of AX. Changing AX's value will change AH and AL and
{\em vice versa}\/. The general purpose registers are used in many of
the data movement and arithmetic instructions.

\begin{figure}
\begin{center}
\begin{tabular}{cc}
\multicolumn{2}{c}{AX} \\
\hline
\multicolumn{1}{||c|}{AH} & \multicolumn{1}{c||}{AL} \\
\hline
\end{tabular}
\caption{The AX register \label{fig:AX_reg} }
\end{center}
\end{figure}

There are two 16-bit index registers\index{register!index}: SI and
DI. They are often used as pointers, but can be used for many of the
same purposes as the general registers. However, they can not be
decomposed into 8-bit registers.

The 16-bit BP and SP registers are used to point to data in the
machine language stack and are called the Base Pointer\index{register!base pointer}
and Stack Pointer\index{register!stack pointer}, respectively. These will be discussed later.

The 16-bit CS, DS, SS and ES registers are \emph{segment
registers}. \index{register!segment} They denote what memory is used
for different parts of a program. CS stands for Code Segment, DS for
Data Segment, SS for Stack Segment and ES for Extra Segment. ES is
used as a temporary segment register. The details of these registers
are in Sections~\ref{real_mode} and \ref{16prot_mode}.

The Instruction Pointer (IP) \index{register!IP} register is used with
the CS register to keep track of the address of the next instruction
to be executed by the CPU. Normally, as an instruction is executed, IP
is advanced to point to the next instruction in memory.

The FLAGS \index{register!FLAGS} register stores important information
about the results of a previous instruction. These results are stored
as individual bits in the register. For example, the Z bit is 1 if the
result of the previous instruction was zero or 0 if not zero. Not all
instructions modify the bits in FLAGS, consult the table in the
appendix to see how individual instructions affect the FLAGS register.

\subsection{80386 32-bit registers\index{register!32-bit}}

The 80386 and later processors have extended registers. For example, the
16-bit AX register is extended to be 32-bits. To be backward compatible, AX
still refers to the 16-bit register and EAX is used to refer to the extended
32-bit register. AX is the lower 16-bits of EAX just as AL is the lower 8-bits
of AX (and EAX). There is no way to access the upper 16-bits of EAX directly.
The other extended registers are EBX, ECX, EDX, ESI and EDI.

Many of the other registers are extended as well. BP becomes
EBP\index{register!base pointer}; SP becomes ESP\index{register!stack
pointer}; FLAGS becomes EFLAGS\index{register!EFLAGS} and IP becomes
EIP\index{register!EIP}. However, unlike the index and general purpose
registers, in 32-bit protected mode (discussed below) only the
extended versions of these registers are used.

The segment registers are still 16-bit in the 80386. There are also
two new segment registers: FS and GS\index{register!segment}. Their
names do not stand for anything. They are extra temporary segment
registers (like ES).

One of definitions of the term \emph{word} \index{word} refers to the
size of the data registers of the CPU. For the 80x86 family, the term
is now a little confusing. In Table~\ref{tab:mem_units}, one sees that
\emph{word} is defined to be 2 bytes (or 16 bits). It was given this
meaning when the 8086 was first released. When the 80386 was
developed, it was decided to leave the definition of \emph{word}
unchanged, even though the register size changed.
\index{register|)}

\subsection{Real Mode \label{real_mode} \index{real mode|(}}

In \MarginNote{So where did the infamous DOS 640K limit come from? The BIOS
required some of the 1M for its code and for hardware devices like the video
screen.} real mode, memory is limited to only one megabyte ($2^{20}$ bytes).
Valid
address range from (in hex) 00000 to FFFFF.\@  % \@ means end of sentence
These addresses require a 20-bit number. Obviously, a 20-bit number will not
fit into any of the 8086's 16-bit registers. Intel solved this problem, by
using two 16-bit values to determine an address. The first 16-bit value is called
the \emph{selector}. Selector values must be stored in segment registers. The
second 16-bit value is called the \emph{offset}. The physical address
referenced by a 32-bit \emph{selector:offset} pair is computed by the formula
\[ 16 * {\rm selector} + {\rm offset} \]
Multiplying by 16 in hex is easy, just add a 0 to the right of the number. For
example, the physical addresses referenced by 047C:0048 is given by:
\begin{center}
\begin{tabular}{r}
047C0 \\
+0048 \\
\hline
04808 \\
\end{tabular}
\end{center}
In effect, the selector value is a paragraph number
(see Table~\ref{tab:mem_units}).

Real segmented addresses have disadvantages:
\begin{itemize}
\item A single selector value can only reference 64K of memory (the
upper limit of the 16-bit offset). What if a program has more than 64K
of code? A single value in CS can not be used for the entire execution
of the program.  The program must be split up into sections (called
\emph{segments}\index{memory!segments}) less than 64K in size. When
execution moves from one segment to another, the value of CS must be
changed. Similar problems occur with large amounts of data and the DS
register. This can be very awkward!

\item Each byte in memory does not have a unique segmented address. The
physical address 04808 can be referenced by 047C:0048, 047D:0038, 047E:0028
or 047B:0058.\@ This can complicate the comparison of segmented addresses.

\end{itemize}
\index{real mode|)}

\subsection{16-bit Protected Mode \label{16prot_mode} \index{protected mode!16-bit|(}}

In the 80286's 16-bit protected mode, selector values are interpreted
completely differently than in real mode. In real mode, a selector
value is a paragraph number of physical memory. In protected mode, a
selector value is an \emph{index} into a \emph{descriptor table}. In
both modes, programs are divided into
segments\index{memory:segments}. In real mode, these segments are at
fixed positions in physical memory and the selector value denotes the
paragraph number of the beginning of the segment. In protected mode,
the segments are not at fixed positions in physical memory. In fact,
they do not have to be in memory at all!

Protected mode uses a technique called \emph{virtual memory}
\index{memory!virtual}. The basic idea of a virtual memory system is
to only keep the data and code in memory that programs are currently
using. Other data and code are stored temporarily on disk until they
are needed again.  In 16-bit protected mode, segments are moved
between memory and disk as needed. When a segment is returned to
memory from disk, it is very likely that it will be put into a
different area of memory that it was in before being moved to
disk. All of this is done transparently by the operating system. The
program does not have to be written differently for virtual memory to
work.

In protected mode, each segment is assigned an entry in a descriptor table.
This entry has all the information that the system needs to know about the
segment. This information includes: is it currently in memory; if in memory,
where is it; access permissions ({\em e.g.\/}, read-only). The index of the
entry of the segment is the selector value that is stored in segment registers.

One \MarginNote{One well-known PC columnist called the 286 CPU ``brain
dead.''} big disadvantage of 16-bit protected mode is that offsets
are still 16-bit quantities. As a consequence of this, segment sizes
are still limited to at most 64K. This makes the use of large arrays
problematic!
\index{protected mode!16-bit|)}

\subsection{32-bit Protected Mode\index{protected mode!32-bit|(}}

The 80386 introduced 32-bit protected mode. There are two major differences
between 386 32-bit and 286 16-bit protected modes:
\begin{enumerate}
\item

Offsets are expanded to be 32-bits. This allows an offset to range up
to 4 billion. Thus, segments can have sizes up to 4 gigabytes.

\item

Segments\index{memory!segments} can be divided into smaller 4K-sized
units called \emph{pages}\index{memory!pages}. The virtual
memory\index{memory!virtual} system works with pages now instead of
segments. This means that only parts of segment may be in memory at
any one time. In 286 16-bit mode, either the entire segment is in
memory or none of it is. This is not practical with the larger
segments that 32-bit mode allows.

\end{enumerate}

\index{protected mode!32-bit|)}

In Windows 3.x, \emph{standard mode} referred to 286 16-bit protected mode and
\emph{enhanced mode} referred to 32-bit mode. Windows 9X, Windows NT/2000/XP, OS/2
and Linux all run in paged 32-bit protected mode.

\subsection{Interrupts\index{interrupt}}

Sometimes the ordinary flow of a program must be interrupted to process events
that require prompt response. The hardware of a computer provides a mechanism
called \emph{interrupts} to handle these events. For example, when a mouse is
moved, the mouse hardware interrupts the current program to handle the mouse
movement (to move the mouse cursor, {\em etc.\/}) Interrupts cause control to
be passed to an \emph{interrupt handler}. Interrupt handlers are routines that
process the interrupt. Each type of interrupt is assigned an integer number.
At the beginning of physical memory, a table of \emph{interrupt vectors}
resides that contain the segmented addresses of the interrupt handlers. The
number of interrupt is essentially an index into this table.

External interrupts are raised from outside the CPU. (The mouse is an
example of this type.) Many I/O devices raise interrupts ({\em
e.g.\/}, keyboard, timer, disk drives, CD-ROM and sound
cards). Internal interrupts are raised from within the CPU, either
from an error or the interrupt instruction. Error interrupts are also
called \emph{traps}. Interrupts generated from the interrupt
instruction are called \emph{software interrupts}. DOS uses these types of
interrupts to implement its API (Application Programming Interface). More
modern operating systems (such as Windows and UNIX) use a C based interface.
\footnote{However, they may use a lower level interface at the kernel level.}

Many interrupt handlers return control back to the interrupted program
when they finish. They restore all the registers to the same values
they had before the interrupt occurred. Thus, the interrupted program
runs as if nothing happened (except that it lost some CPU
cycles). Traps generally do not return. Often they abort the program.

\section{Assembly Language}

\subsection{Machine language\index{machine language}}

Every type of CPU understands its own machine language. Instructions
in machine language are numbers stored as bytes in memory. Each
instruction has its own unique numeric code called its \emph{operation
code} or \emph{opcode} \index{opcode} for short. The 80x86 processor's
instructions vary in size.  The opcode is always at the beginning of
the instruction. Many instructions also include data ({\em e.g.\/},
constants or addresses) used by the instruction.

Machine language is very difficult to program in directly. Deciphering the
meanings of the numerical-coded instructions is tedious for humans. For
example, the instruction that says to add the EAX and EBX registers together
and store the result back into EAX is encoded by the following hex codes:
\begin{quote}
   03 C3
\end{quote}
This is hardly obvious. Fortunately, a program called an
\emph{assembler} \index{assembler} can do this tedious work for the
programmer.

\subsection{Assembly language\index{assembly language|(}}

An assembly language program is stored as text (just as a higher level language
program). Each assembly instruction represents exactly one machine instruction.
For example, the addition instruction described above would be represented
in assembly language as:
\begin{CodeQuote}
   add eax, ebx
\end{CodeQuote}
Here the meaning of the instruction is \emph{much} clearer than in
machine code. The word {\code add} is a \emph{mnemonic}
\index{mnemonic} for the addition instruction.  The general form of an
assembly instruction is:
\begin{CodeQuote}
  {\em mnemonic operand(s)}
\end{CodeQuote}

An \emph{assembler} \index{assembler} is a program that reads a text
file with assembly instructions and converts the assembly into machine
code.  \emph{Compilers} \index{compiler} are programs that do similar
conversions for high-level programming languages. An assembler is much
simpler than a compiler. \MarginNote{It took several years for
computer scientists to figure out how to even write a compiler!} Every
assembly language statement directly represents a single machine
instruction. High-level language statements are \emph{much} more
complex and may require many machine instructions.

Another important difference between assembly and high-level languages is that
since every different type of CPU has its own machine language, it also has
its own assembly language. Porting assembly programs between different computer
architectures is \emph{much} more difficult than in a high-level language.

This book's examples uses the Microsoft's Assembler or MASM \index{MASM}
for short. It is freely available off the Internet. More common assemblers are Netwide Assembler (NASM)
\index{NASM} or Borland's Assembler (TASM). \index{TASM} There are
some differences in the assembly syntax for MASM/TASM and NASM, but the
big ideas are the same.

\subsection{Instruction operands}

Machine code instructions have varying number and type of operands; however,
in general, each instruction itself will have a fixed number of operands (0
to 3). Operands can have the following types:
\begin{description}
\item[register:]
These operands refer directly to the contents of the CPU's registers.
\item[memory:]
These refer to data in memory. The address of the data may be a constant
hardcoded into the instruction or may be computed using values of registers.
Address are always offsets from the beginning of a segment.
\item[immediate:]
\index{immediate}
These are fixed values that are listed in the instruction itself. They are
stored in the instruction itself (in the code segment), not in the data
segment.
\item[implied:]
These operands are not explicitly shown. For example, the increment
instruction adds one to a register or memory. The one is implied.
\end{description}
\index{assembly language|)}

\subsection{Basic instructions}

The most basic instruction is the {\code MOV} \index{MOV} instruction. It moves
data from one location to another (like the assignment operator in a
high-level language). It takes two operands:
\begin{CodeQuote}
  mov {\em dest, src}
\end{CodeQuote}
The data specified by {\em src} is copied to {\em dest\/}. One restriction
is that both operands may not be memory operands. This points out another
quirk of assembly. There are often somewhat arbitrary rules about how the
various instructions are used. The operands must also be the same size. The
value of AX can not be stored into BL.

\lstset{%frame=tb,
   language=[x86masm]Assembler,
   morekeywords={.code},
   aboveskip=3mm,
   belowskip=3mm,
   showstringspaces=false,
   columns=flexible,
   basicstyle={\small\ttfamily},
   numbers=left,%none,%
   numberstyle=\tiny\color{gray},
   keywordstyle=\color{blue},
   commentstyle=\color{dkgreen},
   stringstyle=\color{mauve},
   breaklines=true,
   frame=none,
   breakatwhitespace=true,
   tabsize=3
   }

Here is an example (semicolons start a comment\index{comment}):
%\begin{AsmCodeListing}[frame=none, numbers=none]
\begin{lstlisting}[language={[x86masm]Assembler}]
  mov    eax, 3   ; store 3 into EAX register (3 is immediate operand)
  mov    bx, ax   ; store the value of AX into the BX register
\end{lstlisting}
%AsmCodeListing}

The {\code ADD} \index{ADD} instruction is used to add integers.
\begin{lstlisting}[language={[x86masm]Assembler}]
  add    eax, 4   ; eax = eax + 4
  add    al, ah   ; al = al + ah
\end{lstlisting}

The {\code SUB} \index{SUB} instruction subtracts integers.
\begin{lstlisting}[language={[x86masm]Assembler}]
  sub    bx, 10   ; bx = bx - 10
  sub    ebx, edi ; ebx = ebx - edi
\end{lstlisting}

The {\code INC} \index{INC} and {\code DEC} \index{DEC} instructions
increment or decrement values by one. Since the one is an implicit
operand, the machine code for {\code INC} and {\code DEC} is smaller
than for the equivalent {\code ADD} and {\code SUB} instructions.
\begin{lstlisting}[language={[x86masm]Assembler}]
  inc    ecx      ; ecx++
  dec    dl       ; dl--
\end{lstlisting}

\subsection{Directives\index{directive|(}}

A \emph{directive} is an artifact of the assembler not the CPU. They are
generally used to either instruct the assembler to do something or inform
the assembler of something. They are not translated into machine code. Common
uses of directives are:
\begin{list}{$\bullet$}{\setlength{\itemsep}{0pt}}
\item define constants
\item define memory to store data into
\item group memory into segments
\item conditionally include source code
\item include other files
\end{list}

\subsubsection{The equ directive\index{directive!equ}}

The {\code equ} directive can be used to define a \emph{symbol}. Symbols are
named constants that can be used in the assembly program. The format is:
\begin{quote}
  \code {\em symbol} equ {\em value}
\end{quote}
Symbol values can \emph{not} be redefined later.

\subsubsection{Data directives\index{directive!data|(}}

\begin{table}[t]
\centering
\begin{tabular}{||c|c||} \hline
{\bf Unit} & {\bf Letter} \\
\hline
byte & B \\
word & W \\
double word & D \\
quad word & Q \\
ten bytes & T \\
\hline
\end{tabular}
\caption{Letters for {\code DX} Directives
         \label{tab:size-letters} }
\end{table}

Data directives are used in data segments to define room for
memory. There are two ways memory can be reserved. The first way only
defines room for data; the second way defines room and an initial
value. You can use a ? to reserve uninitialized memory for a given size,
or you can give the memory location an initial value.
%The first method uses one of the {\code RES{\em
%X}}\index{directive!RES\emph{X}} directives. The {\em X} is replaced
%with a letter that determines the size of the object (or objects) that
%will be stored.
Table~\ref{tab:size-letters} shows the possible
values for the different sizes of data.

%The second method (that defines an initial value, too) uses one of the
%{\code D{\em X}} directives\index{directive!D\emph{X}}. The {\em X}
%letters are the same as those in the {\code RES{\em X}} directives.


It is very common to mark memory locations with
\emph{labels}. \index{label} Labels allow one to easily refer to
memory locations in code. Below are several examples:
\begin{lstlisting}[language={[x86masm]Assembler}]
L1  db  0        ; byte labeled L1 with initial value 0
L2  dw  1000     ; word labeled L2 with initial value 1000
L3  db  110101b  ; byte initialized to binary 110101 (53 in decimal)
L4  db  12h      ; byte initialized to hex 12 (18 in decimal)
L5  db  17o      ; byte initialized to octal 17 (15 in decimal)
L6  dd  1A92h    ; double word initialized to hex 1A92
L7  db  ?        ; 1 uninitialized byte
L8  db  "A"      ; byte initialized to ASCII code for A (65)
\end{lstlisting}

Double quotes and single quotes are treated the same. Consecutive data
definitions are stored sequentially in memory. That is, the word L2 is
stored immediately after L1 in memory. Sequences of memory may also be
defined, which we'll see later can be treated as arrays.
\begin{lstlisting}[language={[x86masm]Assembler}]
L9   db    0, 1, 2, 3              ; defines 4 bytes
L10  db    "w", "o", "r", 'd', 0   ; defines a C string = "word"
L11  db    'word', 0                ; same as L10
\end{lstlisting}

The {\code DD}\index{directive!DD} directive can be used to define
both integer and single precision floating point\footnote{Single
precision floating point is equivalent to a {\code float} variable in
C.} constants. However, the {\code DQ}\index{directive!DQ} can only
be used to define double precision floating point constants.

For large sequences,  {\code DUP} \index{directive!DUP}
directive is often useful. This directive repeats its operand a
specified number of times. For example,
\begin{lstlisting}[language={[x86masm]Assembler}]
L12  db 100 dup (0)                 ; equivalent to 100 (db 0)'s
L13  dw 100 dup (?)                 ; reserves room for 100 words
\end{lstlisting}
\index{directive!data|)}
\index{directive|)}

\index{label|(}
Remember that labels can be used to refer to data in code. There are
two ways that a label can be used. If a plain label is used, it is
interpreted as the data at the address (or offset) of the label. If the label is
used with the offset operator, it is interpreted as the address of the data.  You might notice that labels act like variables in higher level languages.
In 32-bit mode, addresses are 32-bit. Here are some examples:
\begin{lstlisting}[language={[x86masm]Assembler}]
mov  al, L1      ; copy byte at L1 into AL
mov  eax, offset L1    ; EAX = address of byte at L1
mov  L1, ah      ; copy AH into byte at L1
mov  eax, L6     ; copy double word at L6 into EAX
add  eax, L6     ; EAX = EAX + double word at L6
add  L6, eax     ; double word at L6 += EAX
mov  al, byte ptr L6   ; copy first byte of double word at L6 into AL
\end{lstlisting}
Line 7 of the examples shows an important property of assembly. The assembler does
\emph{not} keep track of the type of data that a label refers to. It is up
to the programmer to make sure that he (or she) uses a label correctly. Later
it will be common to store addresses of data in registers and use the register
like a pointer variable in C. Again, no checking is made that a pointer is
used correctly. In this way, assembly is much more error prone than even C.
\index{label|)}

\subsection{Input and Output \index{I/O|(}}

Input and output are very system dependent activities. It involves
interfacing with the system's hardware. High level languages, like C,
provide standard libraries of routines that provide a simple, uniform
programming interface for I/O.  Assembly languages provide no standard
libraries. They must either directly access hardware (which is a privileged
operation in protected mode) or use whatever low level routines that the
operating system provides.


It is very common for assembly routines to be interfaced with C. One
advantage of this is that the assembly code can use the standard C
library I/O routines.  However, one must know the rules for passing
information between routines that C uses. These rules are too
complicated to cover here. 

To start with, you will be creating your own assembly interpreter so you can
debug with a language you are already familiar with.  Then we'll switch over
to "real" assembly and you'll write your own output procedures for debugging.
\index{I/O|)}

\section{Creating a Program}

Today, it is unusual to create a stand alone program written
completely in assembly language. Assembly is usually used to key certain
critical routines. Why? It is \emph{much} easier to program in a higher level
language than in assembly. Also, using assembly makes a program very hard to
port to other platforms. In fact, it is rare to use assembly at all.

So, why should anyone learn assembly at all?
\begin{enumerate}
\item Sometimes code written in assembly can be faster and smaller than
      compiler generated code.
\item Assembly allows access to direct hardware features of the system that
      might be difficult or impossible to use from a higher level language.
\item Learning to program in assembly helps one gain a deeper understanding of
      how computers work.
\item Learning to program in assembly helps one understand better how compilers
      and high level languages like C work.
\end{enumerate}
These last two points demonstrate that learning assembly can be useful even if
one never programs in it later. In fact, the author rarely programs in
assembly, but he uses the ideas he learned from it everyday.

\subsection{First program}

As is traditional, here is "Hello, world!" in assembly.  We will learn about interrupts ({\code int})
later, but for now just know that you can now add assembly to your resume.

%\begin{lstlisting}[language={[x86masm]Assembler}]
%title Hello World Program         (hello.asm)

%;This program displays "Hello, world!"
%.model small ;small 64k 16 bit
%.stack 100h ;reserves 256 bytes for the stack
%.data ;start definition of variables
%message db "Hello, world!",0dh,0ah,'$' ;message as character array

%.code ;start code portion of program
%main proc ;start of the main procedure
%    mov  ax,@data ;load the address of the data segment into ax
%    mov  ds,ax ;load the address of the data segment into ds

%    mov  ah,9 ;setting for outputting a string
%    mov  dx,offset message ;point dx to the string
 %   int  21h ;output the string

%    mov  ax,4C00h ;exit (ah) with code 0 (al)
 %   int  21h ;exit
%main endp ;end procedure

%end main ;end program
%\end{lstlisting}


\lstinputlisting{../code/hello.asm}




%\begin{figure}
%\centering
%  \includegraphics[width=3in]{hello_world.jpg} %image not OER
%  \caption{Hello World.}
%  \label{fig:helloworld}
%\end{figure}


Line~6 of the program defines a section of the program that specifies
memory to be stored in the data segment (whose name is {\code
.data})\index{data segment}. On line 7, a string is declared. It
will be printed with the interrupt and so must be terminated with a
\$ character.

The code segment \index{code segment} is named {\code .code},
it is where instructions are placed.

\subsection{Compiler dependencies}

We will be using the MASM assembler in combination with DOSBox
both of which can be downloaded from the course website later in the semester.

\subsection{Assembling the code}

The first step is to assemble the code. From the command line, type:
\begin{CodeQuote}
ml hello.asm
\end{CodeQuote}

This will assemble and link your program into an executable which will
be named hello.exe.

You can run your program (assuming there were no errors) with:
\begin{CodeQuote}
hello
\end{CodeQuote}

And it should print:
\begin{CodeQuote}
Hello, world!
\end{CodeQuote}
to the console. 


 {\index{directive!global}  %why is this line important?

\subsection{Understanding an assembly listing file \index{listing file|(}}

The {\code /l {\em listing-file}} switch can be used to tell {\code
masm} to create a listing file of a given name. This file shows how
the code was assembled. Here is how line~8 (in the data
segment) appear in the listing file.

%\begin{Verbatim}[xleftmargin=\AsmMargin]
\begin{lstlisting}[language={[x86masm]Assembler},firstnumber=8]
0000 48 65 6C 6C 6F 2C	    message db "Hello, world!",0dh,0ah,'$'
      20 77 6F 72 6C 64
      21 0D 0A 24
 \end{lstlisting}%Verbatim}
The first column in each line is the
offset (in hex) of the data in the segment. The second column shows the
raw hex values that will be stored. In this case the hex data
correspond to ASCII codes. Finally, the text from the source file is
displayed on the line. The offsets listed in the second column are
very likely \emph{not} the true offsets that the data will be placed
at in the complete program.  Each module may define its own labels in
the data segment (and the other segments, too). In the link step, all these data segment label definitions
are combined to form one data segment. The new final offsets are then
computed by the linker.

Here is a small section (lines~15 to 16 of the source file) of the
text segment in the listing file:
\begin{lstlisting}[language={[x86masm]Assembler},firstnumber=15]
0005  B4 09			    mov  ah,9 ;setting for outputting a string
0007  BA 0000 R		 mov  dx,offset message ;point dx to the string
\end{lstlisting}%Verbatim}
The second column shows the machine code generated by the
assembly. Often the complete code for an instruction can not be
computed yet. For example, in line~16 the offset (or address) of
{\code message} is not known until the code is linked. The assembler
can compute the op-code for the {\code mov} instruction (which from
the listing is BA), but it doesn't write the offset
because the exact value can not be computed yet. In this case, it lists R
after to signify that the linker must resolve the address.  When the code is linked,
the linker will insert the correct offset into the position. Other
instructions, like line~15, do not reference any labels. Here the assembler
can compute the complete machine code.  Here are the same two lines after linking:
\begin{lstlisting}[language={[x86masm]Assembler},firstnumber=15]
05EF:0005  B4 09             mov  ah,9 
05EF:0007  BA 0200	        mov  dx,0002
\end{lstlisting}
Notice how the machine code for line 15 is the same, but on line 16 {\code offset message} is replaced by the offset of the message within the data segment, namely {\code 0002}.  Also the {\code 0000 R} has been replaced by {\code 0200} which is the little endian representation of {\code 0002} (see the next section for a description of little endian representation).  
\index{listing file|)}

\subsubsection{Big and Little Endian Representation \index{endianess|(}}
Different
processors store multibyte integers in different orders in
memory. There are two popular methods of storing integers: \emph{big
endian} and \emph{little endian}.  Big endian is the method that seems the most
natural. The biggest (\emph{i.e.} most significant) byte is stored
first, then the next biggest, \emph{etc.} For example, the dword
00000004 would be stored as the four bytes 00~00~00~04.  IBM
mainframes, most RISC processors and Motorola processors all use this
big endian method. However, Intel-based processors use the little
endian method! Here the least significant byte is stored first. So,
00000004 is stored in memory as 04~00~00~00. This format is hardwired
into the CPU and can not be changed. Normally, the programmer does not
need to worry about which format is used. However, there are
circumstances where it is important.
\begin{enumerate}
\item When binary data is transferred between different computers (either from
      files or through a network).
\item When binary data is written out to memory as a multibyte integer and
      then read back as individual bytes or \emph{vice versa}.
\end{enumerate}

Endianness does not apply to the order of array elements. The first
element of an array is always at the lowest address. This applies to
strings (which are just character arrays). Endianness still
applies to the individual elements of the arrays.
\index{endianess|)}

\begin{figure}[t]
\lstinputlisting{../code/skel.asm}
\caption{Skeleton Program \label{fig:skel}}
\end{figure}

\section{Skeleton File \index{skeleton file}}

Figure~\ref{fig:skel} shows a skeleton file that can be used as a starting
point for writing assembly programs.
